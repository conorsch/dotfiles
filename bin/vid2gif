#!/usr/bin/perl
# quick script to convert a video file to a GIF based on time indicators;
use strict;
use warnings;
use diagnostics;      # useful for debugging;
use feature 'say';    # beats print;
use Getopt::Long;     # for parsing command-line options;
use File::Temp;       # for tempdirs to store scratch files;
use File::Find;       # for traversing directories and pruning files;
use File::Spec;       # for converting relative paths to absolute paths;
$|++;                 # disable line-buffering, for real-time output;

my $usage = <<'END';
vid2gif

Convert a video file to an animated GIF. Accepts arguments for start time 
of GIF in the video file, length of video segment to convert to GIF, and 
resolution for the product GIF. Provides sane defaults for all of these, too.

Usage: 

	vid2gif --start 00:01:10   		# begin GIF at time HH::MM::SS
	vid2gif --length 2		   		# GIF should include 2 seconds of video
	vid2gif --resolution 425x320	# reformat GIF to given dimensions
	vid2gif --output				# name the product GIF
	vid2gif --help		       		# show this usage information

	vid2gif --start 00:00:07 --length 7 --resolution 50x50 video.mp4

Supported options:

	-s, --start 	    # begin GIF at time (HH:MM:SS format)
	-l, --length 	    # number of seconds of video to convert to GIF
	-r, --resolution 	# GIF should be rendered in given dimensions (640x480 format)
	-o, --output 		# GIF should be named with the specified string
	-h, --help 			# show this usage information
	-v, --verbose		# enable chatty output

END

GetOptions(
    'start|s=s'      => \my $start_time,
    'resolution|r=s' => \my $resolution,
    'length|l=s'     => \my $length,
    'output|o=s'     => \my $output_file,
    'help|h|usage|?' => \my $help,
    'verbose|v'      => \my $verbose,
) or die "$usage";

if ( $resolution ) {    # check whether user specified a custom resolution for GIF;
    $resolution =~ s/x/:/;    # swap in a colon where x is more user-friendly;
    $resolution = "-vf scale=$resolution";    # prepend option title if user requested certain resolution;
}
else {                                        # if no custom resolution was requested;
    $resolution = '';                         # set to empty string, so it can still be interpolated in the system() call;
}

if ( $output_file ) {                         # check whether user specified a custom filename for product GIF;
    $output_file =~ s/(\.gif)+?$/\.gif/i;     # make sure there's only one file extension on this thing;
}
else {                                        # if user did not specify a custom name for product GIF;
    $output_file = 'output.gif';              # choose a rather bland default;
}
$output_file = File::Spec->rel2abs( $output_file );
my $video_file = pop @ARGV or die "$usage";    # grab video file as last element on command line;

my $tempdir = File::Temp->newdir                       # create
  or die "Could not create temporary directory $!";    # die on failure;

print "Generating intermediate images... " if $verbose;    # chatty output;
system( "mplayer -quiet -ao null -ss $start_time -endpos $length $video_file -vo jpeg:outdir=$tempdir/ $resolution >/dev/null 2>&1" ) == 0
  or die "Could not generate temporary images; please manually cleanup $tempdir.";    # die on failure
say "done." if $verbose;                                                              # chatty output;

my $orig_count = `ls $tempdir | wc -l`;                                               # grab original file count;
print "Optimizing base frame count... " if $verbose;                                  # chatty output;

my $counter = 1;                                                                      # initialize counter for use while iterating over files;
find(
    {
        wanted => sub {                                                               # declare &wanted subroutine anonymously;
            unlink if $counter % 4;                                                   # keep 25% of the files, toss the rest;
            $counter++;                                                               # increment that counter;
        },
        preprocess => sub {                                                           # prepare directory before running &wanted subroutine;
            return sort @_;    # sort all filenames in this directory, so destruction is ordered;
          }
    },
    $tempdir                   # declare temp directory as target for this find operation;
);
my $final_count = `ls $tempdir | wc -l`;    # grab new file count;
chomp( $orig_count, $final_count );         # remove pesky trailing newline;
say "$orig_count -> $final_count, done." if $verbose;    # chatty output;

print "Assembling full animated GIF... " if $verbose;    # chatty output;
system( "convert -delay 10 $tempdir/*.jpg '$output_file'" )    # shell out to convert to run conversion;
  == 0 or die "Could not create assembled GIF image.";         # die on failure;
say "done." if $verbose;                                       # chatty output;
say "View the file at: $output_file" if $verbose;

File::Temp::cleanup;                                           # remove any unused temp files;
system( "rm -rf $tempdir" )                                    # hard-remove the temp directory, because cleanup() doesn't work if there are files;
  == 0 or die "Failed to clean up temp directory at $tempdir"; # die on failure to remove temp directory;
