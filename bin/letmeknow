#!/usr/bin/perl
# quick script to notify completed comnmands or changes to system state;
use strict;
use warnings;
use diagnostics;      # useful for debugging;
use feature 'say';    # beats print;
use Getopt::Long;     # for parsing command-line options;
use Net::Ping;        # for checking upness of hosts;

my $usage = <<'END';
letmeknow

notify about completed comnmands or changes to system state. 

Run this command if you want to look away from your terminal for a while, 
waiting for a process to complete. Without any arguments it will notify 
when the previous command completes, optionally emailing the user. Make 
sure to use a ~/.forward file, because the mail is sent to the logged in user. 

There are also several convenient shortcuts for checking on state changes: 

    - check for internet 
    - watch for a host to come online 
    - command completes


Usage: 
    letmeknow --by window          # display an X11 window
    letmeknow --by systemtray      # use desktop environment's notification tray
    letmeknow --by email           # send email to current user
    letmeknow --by audio           # make a noise to alert the user 
    letmeknow --message            # declare custom message to display;
    letmeknow --help               # show this usage information

Supported options:

    -h, --help                  # show this usage information
    -v, --verbose               # enable chatty output
END

GetOptions(
    'window|w'       => \my $window,
    'systemtray|s'   => \my $systemtray,
    'email|e'        => \my $email,
    'audio|a'        => \my $audio,
    'by|b'           => \my $by,
    'message|m=s'    => \my $message,
    'help|h|usage|?' => \my $help,
    'verbose|v'      => \my $verbose,
) or die "$usage";

my @clause = @ARGV; # unpack all non-option arguments as a command to run;

if ( $clause[ -1 ] =~ m/^(finish|done|complete)/  # check for '... finishes' structure to command;
     and $#clause > 0 ) { # make sure there are multiple args here, including "finish" request;
    pop @clause; # toss away that word, because we don't need it;
    my $command = join( ' ', @clause ); # assume that remaining arguments constitute a command to be run;

    print "Running command '$command'... " if $verbose; # chatty output;
    system( "$command" ); # shell out to run given operation;
    my $success = not $?; # store that status code;

    if ( $verbose ) { # only do this if chatty output was requested;
        $success ? # check for successful return value (non-zero means failure, so flip it);
            say "done.": # report success;
            say "failed."; # report failure;
        say "SUCCESS IS: '$success'";
    }

    notify_user( $success, $command ) # pass exit value of system() call and the command run to notification subroutine;
        or die "Failed to notify user of command completion."; # die on failure;
}

elsif ( $#clause >= 0 ) { # if arguments were specified, assume it's a command to run;

    my $command = join( ' ', @clause ); # assume that remaining arguments constitute a command to be run;
    print "Running command '$command'... " if $verbose; # chatty output;

    system( "$command" ); # shell out to run given operation;
    my $success = not $?; # store that status code;

    if ( $verbose ) { # only do this if chatty output was requested;
        $success ? # check for successful return value (non-zero means failure, so flip it);
            say "done.": # report success;
            say "failed."; # report failure;
    }

    notify_user( $success, $command ) # pass exit value of system() call and the command run to notification subroutine;
        or die "Failed to notify user of command completion."; # die on failure;
}

sub notify_user { # send notification about command completion, according to options specified;
    my $success = shift or return; # unpack exit value from previous command;
    my @command = @_ or return; # unpack all remaining arguments as the command that was run;
    my $time = localtime; # grab scalar time value for reporting;
    my $notification; # initialize variable for storing message string;

    $notification = "The following command completed successfully:\n\n@command\n\nat $time." if $success;
    $notification = "The following command failed:\n\n@command\n\nat $time." if not $success;

    my $notify_command; # initialize string to shell out to notification system;

    if ( $window ) { # if user requested that an X11 window be drawn with notification;
        $notify_command = "kdialog --msgbox '$notification'"
            if system( "which kdialog >/dev/null 2>&1" ) == 0; # only do this if package is installed;

        system( $notify_command ) if $notify_command; # only shell out if supported command is found;
    }

    if ( $email ) { # if user requested that an email be sent as notification;
        $notify_command = "sendmail -s 'Operation complete' -t " . getpwuid( $< );

        open my $mail_tube, '>', "$notify_command |" # open pipe to mail command, for writing notification to;
            or die "Could not open pipe to mail $!"; # die on failure to open mail pipe;

        say $mail_tube $notification; # write to pipe;
        close $mail_tube # close pipe, which sends mail;
            or die "Could not close pipe to mail $!"; # die on failure to close mail pipe;
    }

    say $notification # display notification message in terminal;
        unless $window or $email; # don't do this if another method was specified;
}
