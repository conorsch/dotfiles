#!/usr/bin/perl
# quick script to notify completed comnmands or changes to system state;
use strict;
use warnings;
use diagnostics;      # useful for debugging;
use feature 'say';    # beats print;
use Getopt::Long;     # for parsing command-line options;
use Net::Ping;        # for checking upness of hosts;

my $usage = <<'END';
letmeknow

notify about completed comnmands or changes to system state. 

Run this command if you want to look away from your terminal for a while, 
waiting for a process to complete. Without any arguments it will notify 
when the previous command completes, optionally emailing the user. Make 
sure to use a ~/.forward file, because the mail is sent to the logged in user. 

There are also several convenient shortcuts for checking on state changes: 

    - check for internet 
    - watch for a host to come online 
    - command completes


Usage: 
    letmeknow --by window          # display an X11 window
    letmeknow --by systemtray      # use desktop environment's notification tray
    letmeknow --by email           # send email to current user
    letmeknow --by audio           # make a noise to alert the user 
    letmeknow --message            # declare custom message to display;
    letmeknow --help               # show this usage information

Supported options:

    -h, --help                  # show this usage information
    -v, --verbose               # enable chatty output
END

GetOptions(
    'window|w'       => \my $window,
    'systemtray|s'   => \my $systemtray,
    'email|e'        => \my $email,
    'audio|a'        => \my $audio,
    'by|b'           => \my $by,
    'message|m=s'    => \my $message,
    'help|h|usage|?' => \my $help,
    'verbose|v'      => \my $verbose,
) or die "$usage";

my @clause = @ARGV; # unpack all non-option arguments as a command to run;

if ( $clause[ -1 ] =~ m/^(finish|done|complete)/  # check for '... finishes' structure to command;
     and $#clause > 0 ) { # make sure there are multiple args here, including "finish" request;
    pop @clause; # toss away that word, because we don't need it;
    my $command = join( ' ', @clause ); # assume that remaining arguments constitute a command to be run;

    print "Running command '$command'... " if $verbose; # chatty output;
    system( "$command" ); # shell out to run given operation;
    my $success = not $?; # store that status code;

    if ( $verbose ) { # only do this if chatty output was requested;
        $success ? # check for successful return value (non-zero means failure, so flip it);
            say "done.": # report success;
            say "failed."; # report failure;
        say "SUCCESS IS: '$success'";
    }

    notify_user( $success, $command ) # pass exit value of system() call and the command run to notification subroutine;
        or die "Failed to notify user of command completion."; # die on failure;
}

sub notify_user { # send notification about command completion, according to options specified;
    my $success = shift or return; # unpack exit value from previous command;
    my @command = @_ or return; # unpack all remaining arguments as the command that was run;
    ...
}
