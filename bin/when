#!/usr/bin/perl
# quick script to chain commands conditionally;
use strict;
use warnings;
use diagnostics; # useful for debugging;
use feature 'say'; # beats print;
use Getopt::Long; # for parsing command-line options;

my $usage = <<'END';
when

chain commands conditionally. 

Usage: 
    when --option 1        
    when --option 2         
    when --help            # show this usage information

Supported options:

    -i, --interval             # specify how many seconds between each attempt
    -h, --help             # show this usage information
    -v, --verbose        # enable chatty output


END

GetOptions ( 
        'interval|i=s'    =>    \my $interval,
        'help|h|usage|?'    =>    \my $help,
        'verbose|v'            =>    \my $verbose,
        ) or die "$usage";


### BEGIN main logic ###
$interval = 5 unless $interval; # set default if user omitted option;

if ( $ARGV[-2] # if user specified a host to check on...
        and $ARGV[-1] =~ m/[up|online|u|on]/i ) { # by asking about 'up' or 'online' status;

    my $host = $ARGV[ -2 ]; # lexicalize what must be the host identifying string;

    print "Waiting for host '$host' to come online... " if $verbose; # chatty output;

    wait_for_it( sub { # feed in code reference to block until true for;
        check_host( $host ); # check whether host is online (pingable);
    }); # wait around until it happens;

    say "$host now online!" if $verbose; # chatty output;
}

elsif ( $#ARGV == 0 # check for exactly one argument...
        and $ARGV[ 0 ] =~ m/^(internet|net|online|on)$/ ) { # and it was about online status;

    print "Waiting for internet connection... " if $verbose; # chatty output;
    wait_for_it( sub { # feed in code reference to block until true for;
        check_internet(); # check whether online connection exists;
    }); # wait around until it happens;
    say "now online!" if $verbose; # chatty output;
}

else { # if input was not understood;
    say $usage; # display help/usage info;
    exit 1; # exit error;
}
### END main logic ###

### subroutines ###
sub check_internet { # check for online status;

#        return not system( "nm-online" ) # return result of nm-online check...;
#            if system ( "which nm-online >/dev/null 2>&1" ) == 0; # if user has NetworkManager installed;

        return not system( "ping -c 1 google.com >/dev/null 2>&1" ); # return result of nm-online check...;
}

sub wait_for_it { # keep running a code reference until it returns true;
    my $coderef = shift or return; # unpack specified command;
    my $notification = shift; # unpack optional message to display during notification;

    my $go; # initialize flag for success check of provided coderef;
    while ( not $go ) { # check for sign that command completed successfully;
    &$coderef ? # run that test code;
        $go = 1: # if code returned success, let's break out of this;
        sleep $interval; # wait, then try again;
    }

    
    say $notification # notify user in whatever way is appropriate;
        if $notification and $verbose; # only do it if appropriate;
}

sub check_for_ssh_alias { # determine whether host string is an SSH alias;
    my $host = shift or return; # check out that string;
    my $ssh_file = $ENV{ 'HOME' } . '/' . '.ssh/config'; # concatenate filepath;

    open my $ssh, '<', $ssh_file # open up file for reading;
        or return $host; # just give up if we can't open SSH config file;

    my $alias_match; # initialize variable for storing a found entry;


    while ( <$ssh> ) { # read through file, line by line;
        chomp; # remove pesky trailing newline;
        if ( $alias_match ) { # check for found entry in previous run;
            next unless /^\s+Hostname/; # we only want hostname declarations;

            my $hostname = ( split )[ -1 ]; # final element on line nust be hostname;
            say "Using hostname '$hostname' for host '$host'" if $verbose; # chatty output;
            return $hostname;
        }

        else { # if we're still looking for an alias match;

            next unless /^Host/; # we only want host declarations;

            $alias_match = grep { /^$host$/ } split # check each alias on this line for match;
                or next; # skip if no matches were found;
        }

    }
    return $host; # if no match was found, just pass back what we started with;
}


sub check_host { # check whether given host is up by pinging it;
    my $host = shift or return; # unpack host from caller;
    $host = check_for_ssh_alias( $host ) # search for SSH alias for this host;
        or die "Something went wrong with SSH file reading"; # should return same host on failure;

    system( "ping -c 1 $host >/dev/null 2>&1" ); # shell out for ping;

    return not $?; # flip exit code from shell-style to function-style;
}
### subroutines ###
